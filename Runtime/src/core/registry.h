#pragma once


#ifdef CATOS_SCRIPTING_ENABLED
#include "scripting/ScriptingEngine.h"
#endif

#include <fstream>
#include "spdlog/spdlog.h"
#include "typeinfo.h"




using namespace catos;




namespace catos {


    typedef unsigned long long Ref;

    //Core system :)_
    /// The registry is the core system and provides reflection to the rest of the engine
    class Registry {

    public:

        static Registry& get();

        void init();

        template<typename A>
        /// With this function you register a class to the Registry
        TypeInfo& register_class(const std::string& class_name) {


            // This means the user is trying to register a new type!
            if (_register.find(class_name) == _register.end()) {
                _register.insert(std::pair<std::string, TypeInfo>(class_name, TypeInfo{.type_hash = typeid(A).hash_code(), .name=  class_name  }));
                _hash_register.insert(std::pair<size_t, TypeInfo*>(typeid(A).hash_code(), &_register.at(class_name)));
            }


            return _register[class_name];
        };


        void gen_python_bindings_file() {
            std::ofstream out("../../../Resources/Catos/catos.py");

            out << R"(""")" << "\n";

            out << "The Python version of The Catos Game engine\n"
                << "The python api is automatically generated by Catos\n"
                << "NOTE: This API is only for scripting. \n";

            out << R"(""")" << "\n";
            for (auto type : _register) {

                auto namespacePos = type.second.name.find("::");
                auto structPos = type.second.name.find("struct");



                if (namespacePos != std::string::npos) {
                    out << "class " << type.second.name.substr(namespacePos + 2) << ":\n";
                } else {
                    out << "class " << type.second.name.substr(structPos + 7) <<  ":\n";
                }

                for (auto prop : type.second.properties) {
                    out << R"(      """ )" << prop.second->desc <<  R"( """ )" << std::endl;
                    out << "      " << prop.first << " = None\n";
                }

                for (auto meth : type.second.methods) {



                    if (meth.first == "init" || meth.first == "Init") {
                        out << R"(      """ )" << meth.second->desc <<   R"(    """ )" << std::endl;
                        out << "      def __init__(self):\n            pass\n";
                    } else {
                        out << "      def " << meth.first << "(self)";
                        if (meth.second->returnName != "void") { out << " -> " << meth.second->returnName << ":\n"; } else { out << ":\n"; }
                        out << R"(          """ )" << meth.second->desc <<   R"( """ )" << std::endl;
                        out << "          pass\n";
                    }
                }
            }

            out.close();
        }


        /// Returns the registered Type
        template<typename A>
        TypeInfo& get_type() {
            return *(_hash_register[typeid(A).hash_code()]);
        }

        TypeInfo& get_type(size_t hash) {
            return *_hash_register[hash];
        }

        //TODO Dummy function!!!
        /// Prints out the items in the Registry
        void print_current_register() {
            for (auto val : _register) {
                TypeInfo& info = val.second;
                std::cout <<  info.name.c_str() << " { \n";

                for (auto& prop : info.properties) {

                    std::cout << "     " << prop.second->get_type_name() << " " << prop.second->get_name() << ";\n";
                }
                std::cout << "}\n";
            }
        }

        const TypeInfo& get_type(const std::string& name) {
            return (_register[name]);
        }

        const std::unordered_map<std::string, TypeInfo>& entries() {
            return _register;
        }

        template<typename T>
        bool is_type_registered() {
            return is_type_registered(typeid(T).hash_code());
        }

        bool is_type_registered(size_t hash) {
            return _hash_register.find(hash) != _hash_register.end();
        }

        bool is_type_registered(const std::string& type_name) {
            return _register.find(type_name) != _register.end();
        }

        Ref getRef(void* ptr) {
            if (_ptr_register.find(ptr) != _ptr_register.end()) {
                return _ptr_register.at(ptr);
            }


            lastId++;
            _ptr_register.insert({ptr, lastId});

            return lastId;
        };


        const std::unordered_map<void*, Ref>& ptrs() {
            return _ptr_register;
        }


    private:
        Ref lastId = 0;

        std::unordered_map<std::string, TypeInfo> _register;
        std::unordered_map<size_t, TypeInfo*> _hash_register;
        std::unordered_map<void*, Ref> _ptr_register;
    };
}
